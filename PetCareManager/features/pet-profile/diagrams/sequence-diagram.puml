@startuml Pet Profile - Sequence Diagrams

!define USER_COLOR #4CAF50
!define UI_COLOR #2196F3
!define API_COLOR #FF9800
!define SERVICE_COLOR #9C27B0
!define REPO_COLOR #00BCD4
!define EVENT_COLOR #F44336
!define EXTERNAL_COLOR #607D8B

skinparam participant {
    BackgroundColor<<User>> USER_COLOR
    BackgroundColor<<UI>> UI_COLOR
    BackgroundColor<<API>> API_COLOR
    BackgroundColor<<Service>> SERVICE_COLOR
    BackgroundColor<<Repository>> REPO_COLOR
    BackgroundColor<<Event>> EVENT_COLOR
    BackgroundColor<<External>> EXTERNAL_COLOR
    BorderColor #333333
}

skinparam sequenceArrowThickness 2
skinparam roundcorner 10
skinparam maxmessagesize 200

title Pet Profile - Key Sequence Diagrams

== Scenario 1: Register New Pet ==

actor "Pet Owner" as user1 <<User>>
participant "Pet Registration\nForm" as ui1 <<UI>>
participant "API Controller" as api1 <<API>>
participant "PetService" as svc1 <<Service>>
participant "Pet Aggregate" as pet1 <<Domain>>
participant "PetRepository" as repo1 <<Repository>>
participant "EventPublisher" as pub1 <<Event>>
database "SQL Server" as db1

user1 -> ui1 : Fill registration form\n(name, species, breed, etc.)
activate ui1

ui1 -> ui1 : Validate client-side\n(required fields, formats)

user1 -> ui1 : Upload photo
ui1 -> ui1 : Compress & preview image

user1 -> ui1 : Click "Register Pet"

ui1 -> api1 : POST /api/pets\n{RegisterPetCommand}
activate api1

api1 -> api1 : Validate request\n(authentication, authorization)

api1 -> svc1 : RegisterPetAsync(command)
activate svc1

' Check microchip uniqueness
alt Microchip provided
    svc1 -> repo1 : GetByMicrochipAsync(microchip)
    activate repo1
    repo1 -> db1 : SELECT FROM Pets\nWHERE MicrochipNumber = @microchip
    activate db1
    db1 --> repo1 : null (unique)
    deactivate db1
    repo1 --> svc1 : null
    deactivate repo1
else Microchip exists
    repo1 --> svc1 : Existing Pet
    svc1 --> api1 : ValidationException:\n"Microchip already registered"
    api1 --> ui1 : 400 Bad Request
    ui1 --> user1 : Show error message
end

' Create pet aggregate
svc1 -> pet1 : new Pet(command.data)
activate pet1

pet1 -> pet1 : Validate business rules\n• Name required\n• DateOfBirth not future\n• Weight > 0

pet1 -> pet1 : Raise PetRegistered event
note right
    Event Properties:
    • PetId
    • HouseholdId
    • Name, Species, Breed
    • DateOfBirth, Gender
    • RegisteredBy, RegisteredAt
end note

pet1 --> svc1 : Pet created
deactivate pet1

' Persist to database
svc1 -> repo1 : AddAsync(pet)
activate repo1

repo1 -> db1 : BEGIN TRANSACTION
activate db1

repo1 -> db1 : INSERT INTO Pets\n(Id, Name, Species, ...)
db1 --> repo1 : Success

repo1 -> db1 : INSERT INTO DomainEvents\n(PetRegistered)
db1 --> repo1 : Success

repo1 -> db1 : COMMIT TRANSACTION
db1 --> repo1 : Committed
deactivate db1

repo1 --> svc1 : Saved
deactivate repo1

' Publish event
svc1 -> pub1 : Publish(PetRegistered)
activate pub1
pub1 -> pub1 : Queue event for\nasync processing
pub1 --> svc1 : Queued
deactivate pub1

svc1 --> api1 : PetId (Guid)
deactivate svc1

api1 --> ui1 : 201 Created\n{id, name, species}
deactivate api1

ui1 --> user1 : Show success message\nRedirect to pet profile
deactivate ui1

...Asynchronous Event Processing...

participant "Event Processor" as proc1 <<Event>>
participant "PetRegisteredHandler" as handler1 <<Event>>
participant "NotificationService" as notif1 <<External>>

proc1 -> db1 : SELECT FROM DomainEvents\nWHERE IsProcessed = 0
activate proc1
activate db1
db1 --> proc1 : [PetRegistered event]
deactivate db1

proc1 -> handler1 : Handle(PetRegistered)
activate handler1

handler1 -> notif1 : SendWelcomeNotification(householdId, petName)
activate notif1
notif1 --> handler1 : Notification sent
deactivate notif1

handler1 -> handler1 : Create health record template
handler1 -> handler1 : Initialize vaccination schedule
handler1 -> handler1 : Update household statistics

handler1 --> proc1 : Success
deactivate handler1

proc1 -> db1 : UPDATE DomainEvents\nSET IsProcessed = 1, ProcessedAt = NOW()
activate db1
db1 --> proc1 : Updated
deactivate db1
deactivate proc1

|||
|||

== Scenario 2: Record Pet Weight ==

actor "User" as user2 <<User>>
participant "Weight Modal" as ui2 <<UI>>
participant "API Controller" as api2 <<API>>
participant "PetService" as svc2 <<Service>>
participant "Pet Aggregate" as pet2 <<Domain>>
participant "WeightRepository" as repo2 <<Repository>>
participant "EventPublisher" as pub2 <<Event>>
database "SQL Server" as db2

user2 -> ui2 : Click "Record Weight"
activate ui2

ui2 -> api2 : GET /api/pets/{id}
activate api2
api2 -> svc2 : GetPetByIdAsync(id)
activate svc2
svc2 -> repo2 : GetByIdAsync(id)
activate repo2
repo2 -> db2 : SELECT FROM Pets WHERE Id = @id
activate db2
db2 --> repo2 : Pet data
deactivate db2
repo2 --> svc2 : Pet
deactivate repo2
svc2 --> api2 : PetDto
deactivate svc2
api2 --> ui2 : Pet details
deactivate api2

ui2 --> user2 : Display modal with\nprevious weight: 24.5 kg
deactivate ui2

user2 -> ui2 : Enter weight: 26.8 kg\nAdd notes: "After holiday"
activate ui2

user2 -> ui2 : Click "Save"

ui2 -> ui2 : Calculate change:\n+2.3 kg (+9.4%)

ui2 -> api2 : POST /api/pets/{id}/weights\n{weight: 26.8, notes: "..."}
activate api2

api2 -> api2 : Validate:\n• Pet exists\n• Weight > 0\n• User has permission

api2 -> svc2 : RecordWeightAsync(petId, command)
activate svc2

' Get current pet state
svc2 -> repo2 : GetByIdAsync(petId)
activate repo2
repo2 -> db2 : SELECT FROM Pets
activate db2
db2 --> repo2 : Pet (IsDeceased = false)
deactivate db2
repo2 --> svc2 : Pet
deactivate repo2

' Check if deceased
alt Pet is deceased
    svc2 --> api2 : BusinessRuleException:\n"Cannot record weight for deceased pet"
    api2 --> ui2 : 400 Bad Request
    ui2 --> user2 : Show error
end

' Get previous weight
svc2 -> repo2 : GetLatestAsync(petId)
activate repo2
repo2 -> db2 : SELECT TOP 1 FROM WeightRecords\nWHERE PetId = @petId\nORDER BY RecordedAt DESC
activate db2
db2 --> repo2 : Previous: 24.5 kg
deactivate db2
repo2 --> svc2 : WeightRecord (24.5 kg)
deactivate repo2

' Record weight on aggregate
svc2 -> pet2 : RecordWeight(26.8, DateTime.Now, "User1", "After holiday")
activate pet2

pet2 -> pet2 : Create WeightRecord entity\n{id, 26.8, DateTime.Now, ...}

pet2 -> pet2 : Calculate change:\nΔ = 2.3 kg (9.4%)

' Check for anomaly
alt Weight change > 20%
    pet2 -> pet2 : Flag as anomalous
    note right: Triggers alert workflow
end

pet2 -> pet2 : Update CurrentWeight = 26.8

pet2 -> pet2 : Raise PetWeightRecorded event
note right
    Event Properties:
    • PetId, HouseholdId
    • WeightRecordId
    • Weight: 26.8
    • PreviousWeight: 24.5
    • RecordedBy, RecordedAt
end note

pet2 --> svc2 : WeightRecord created
deactivate pet2

' Persist to database
svc2 -> repo2 : AddAsync(weightRecord)
activate repo2

repo2 -> db2 : BEGIN TRANSACTION
activate db2

repo2 -> db2 : INSERT INTO WeightRecords\n(Id, PetId, Weight, 26.8, ...)
db2 --> repo2 : Success

repo2 -> db2 : UPDATE Pets\nSET CurrentWeight = 26.8
db2 --> repo2 : Success

repo2 -> db2 : INSERT INTO DomainEvents\n(PetWeightRecorded)
db2 --> repo2 : Success

repo2 -> db2 : COMMIT TRANSACTION
db2 --> repo2 : Committed
deactivate db2

repo2 --> svc2 : Saved
deactivate repo2

' Publish event
svc2 -> pub2 : Publish(PetWeightRecorded)
activate pub2
pub2 -> pub2 : Queue event
pub2 --> svc2 : Queued
deactivate pub2

svc2 --> api2 : WeightRecordId
deactivate svc2

api2 --> ui2 : 201 Created\n{id, weight, recordedAt}
deactivate api2

ui2 --> user2 : Show success\nUpdate chart with new point
deactivate ui2

...Asynchronous Event Processing...

participant "Event Processor" as proc2 <<Event>>
participant "WeightRecordedHandler" as handler2 <<Event>>
participant "AnalyticsService" as analytics <<External>>
participant "NotificationService" as notif2 <<External>>

proc2 -> db2 : SELECT unprocessed events
activate proc2
activate db2
db2 --> proc2 : [PetWeightRecorded]
deactivate db2

proc2 -> handler2 : Handle(PetWeightRecorded)
activate handler2

handler2 -> analytics : UpdateWeightTrend(petId)
activate analytics
analytics --> handler2 : Trend updated
deactivate analytics

alt Weight change > 20%
    handler2 -> notif2 : SendAlert(householdId,\n"Significant weight change detected")
    activate notif2
    notif2 --> handler2 : Alert sent
    deactivate notif2
else Normal change
    handler2 -> notif2 : SendUpdate(householdId,\n"Weight recorded")
    activate notif2
    notif2 --> handler2 : Update sent
    deactivate notif2
end

handler2 --> proc2 : Success
deactivate handler2

proc2 -> db2 : Mark event as processed
activate db2
db2 --> proc2 : Updated
deactivate db2
deactivate proc2

|||
|||

== Scenario 3: Mark Pet as Deceased ==

actor "Owner" as user3 <<User>>
participant "Pet Profile Page" as ui3 <<UI>>
participant "Confirmation Modal" as modal <<UI>>
participant "API Controller" as api3 <<API>>
participant "PetService" as svc3 <<Service>>
participant "Pet Aggregate" as pet3 <<Domain>>
participant "Repository" as repo3 <<Repository>>
participant "EventPublisher" as pub3 <<Event>>
database "SQL Server" as db3

user3 -> ui3 : Click "Mark as Deceased"
activate ui3

ui3 -> modal : Show confirmation
activate modal

modal --> user3 : "Are you sure?\nThis will archive all\nactive appointments."
deactivate modal

user3 -> modal : Enter date: 2025-12-15\nClick "Confirm"
activate modal

modal -> modal : Validate date:\n• Not before birth\n• Not in future

modal -> api3 : POST /api/pets/{id}/mark-deceased\n{dateOfDeath: "2025-12-15"}
activate api3

api3 -> api3 : Validate:\n• User is household owner\n• Pet exists\n• Not already deceased

api3 -> svc3 : MarkAsDeceasedAsync(petId, dateOfDeath)
activate svc3

svc3 -> repo3 : GetByIdAsync(petId)
activate repo3
repo3 -> db3 : SELECT FROM Pets
activate db3
db3 --> repo3 : Pet (IsDeceased = false)
deactivate db3
repo3 --> svc3 : Pet
deactivate repo3

alt Pet already deceased
    svc3 --> api3 : BusinessRuleException:\n"Pet is already marked as deceased"
    api3 --> modal : 400 Bad Request
    modal --> user3 : Show error
end

svc3 -> pet3 : MarkAsDeceased(dateOfDeath)
activate pet3

pet3 -> pet3 : Validate:\n• DateOfDeath >= DateOfBirth\n• DateOfDeath <= Today

pet3 -> pet3 : Set IsDeceased = true\nSet DateOfDeath = 2025-12-15

pet3 -> pet3 : Raise PetPassedAway event
note right
    Event Properties:
    • PetId, HouseholdId
    • PetName
    • DateOfDeath
    • RecordedBy, RecordedAt
end note

pet3 --> svc3 : Pet updated
deactivate pet3

svc3 -> repo3 : UpdateAsync(pet)
activate repo3

repo3 -> db3 : BEGIN TRANSACTION
activate db3

repo3 -> db3 : UPDATE Pets SET\nIsDeceased = 1,\nDateOfDeath = '2025-12-15'
db3 --> repo3 : Success

repo3 -> db3 : INSERT INTO DomainEvents\n(PetPassedAway)
db3 --> repo3 : Success

repo3 -> db3 : COMMIT TRANSACTION
db3 --> repo3 : Committed
deactivate db3

repo3 --> svc3 : Saved
deactivate repo3

svc3 -> pub3 : Publish(PetPassedAway)
activate pub3
pub3 --> svc3 : Queued
deactivate pub3

svc3 --> api3 : Success
deactivate svc3

api3 --> modal : 200 OK
deactivate api3

modal --> user3 : "We're sorry for your loss.\nMax has been marked as deceased."
deactivate modal

ui3 -> ui3 : Apply grayscale filter\nAdd deceased badge
ui3 --> user3 : Update UI
deactivate ui3

...Asynchronous Event Processing...

participant "Event Processor" as proc3 <<Event>>
participant "PetPassedAwayHandler" as handler3 <<Event>>
participant "NotificationService" as notif3 <<External>>
participant "AppointmentService" as appt <<External>>

proc3 -> db3 : SELECT unprocessed events
activate proc3
activate db3
db3 --> proc3 : [PetPassedAway]
deactivate db3

proc3 -> handler3 : Handle(PetPassedAway)
activate handler3

handler3 -> notif3 : SendCondolence(householdId, petName)
activate notif3
notif3 --> handler3 : Condolence sent
deactivate notif3

handler3 -> appt : ArchiveActiveAppointments(petId)
activate appt
appt -> appt : Cancel future appointments\nMark as archived
appt --> handler3 : Appointments archived
deactivate appt

handler3 -> handler3 : Update household statistics\n(decrement active pets)

handler3 -> handler3 : Generate memorial record

handler3 --> proc3 : Success
deactivate handler3

proc3 -> db3 : Mark event as processed
activate db3
db3 --> proc3 : Updated
deactivate db3
deactivate proc3

@enduml
